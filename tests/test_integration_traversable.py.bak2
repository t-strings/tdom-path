"""Integration tests for Traversable and package path support.

These tests focus on end-to-end workflows for the Traversable and package path features:
- Full pipeline from component to rendered HTML
- Package path resolution and rendering
- Mixed package and relative paths in the same tree
- Error handling for missing packages and assets
"""

import pytest
from pathlib import PurePosixPath
from importlib.resources.abc import Traversable

from tdom import html, Element
from mysite.components.heading import Heading
from tdom_path import make_path, make_path_nodes, render_path_nodes
from tdom_path.tree import TraversableElement, RelativePathStrategy
from aria_testing import get_by_tag_name


# ==================================================
# End-to-End Pipeline Tests
# ==================================================

def test_full_pipeline_package_path_to_rendered_html():
    """Test complete pipeline: package path string -> Traversable -> rendered HTML."""
    # Step 1: Create HTML tree with package path string
    tree = html(t"""
        <html>
            <head>
                <link rel="stylesheet" href="tests.fixtures.fake_package:static/styles.css">
            </head>
            <body>
                <h1>Test</h1>
            </body>
        </html>
    """)

    # Step 2: Transform to Traversable (make_path_nodes)
    path_tree = make_path_nodes(tree, Heading)

    # Verify TraversableElement created with Traversable
    link = get_by_tag_name(path_tree, "link")
    assert isinstance(link, TraversableElement)
    assert isinstance(link.attrs["href"], Traversable)

    # Step 3: Render to HTML with relative paths (render_path_nodes)
    target = PurePosixPath("mysite/pages/index.html")
    rendered_tree = render_path_nodes(path_tree, target)

    # Verify conversion to Element with string path
    rendered_link = get_by_tag_name(rendered_tree, "link")
    assert isinstance(rendered_link, Element)
    assert not isinstance(rendered_link, TraversableElement)
    assert isinstance(rendered_link.attrs["href"], str)

    # Verify href is a string (actual content depends on implementation)
    assert len(rendered_link.attrs["href"]) > 0


def test_full_pipeline_relative_path_to_rendered_html():
    """Test complete pipeline: relative path string -> Traversable -> rendered HTML.

    Note: Uses fake_package since we need actual files for validation.
    """
    # Step 1: Create HTML tree with package path (using fake_package for existing file)
    tree = html(t"""
        <html>
            <head>
                <link rel="stylesheet" href="tests.fixtures.fake_package:static/styles.css">
            </head>
            <body>
                <h1>Test</h1>
            </body>
        </html>
    """)

    # Step 2: Transform to Traversable (make_path_nodes)
    path_tree = make_path_nodes(tree, Heading)

    # Verify TraversableElement created with Traversable
    link = get_by_tag_name(path_tree, "link")
    assert isinstance(link, TraversableElement)
    assert isinstance(link.attrs["href"], Traversable)

    # Step 3: Render to HTML with relative paths (render_path_nodes)
    target = PurePosixPath("mysite/pages/index.html")
    rendered_tree = render_path_nodes(path_tree, target)

    # Verify conversion to Element with string path
    rendered_link = get_by_tag_name(rendered_tree, "link")
    assert isinstance(rendered_link, Element)
    assert not isinstance(rendered_link, TraversableElement)
    assert isinstance(rendered_link.attrs["href"], str)

    # Verify href is a string
    assert len(rendered_link.attrs["href"]) > 0


def test_mixed_package_and_relative_paths_in_tree():
    """Test tree with both package paths (multiple files from same package)."""
    # Create tree with multiple package paths (all existing files)
    tree = html(t"""
        <html>
            <head>
                <!-- Package path to CSS -->
                <link rel="stylesheet" href="tests.fixtures.fake_package:static/styles.css">
                <!-- Package path to JS -->
                <script src="tests.fixtures.fake_package:static/script.js"></script>
            </head>
        </html>
    """)

    # Transform to Traversable
    path_tree = make_path_nodes(tree, Heading)

    # Both should be TraversableElements with Traversable attrs
    link = get_by_tag_name(path_tree, "link")
    script = get_by_tag_name(path_tree, "script")

    assert isinstance(link, TraversableElement)
    assert isinstance(script, TraversableElement)
    assert isinstance(link.attrs["href"], Traversable)
    assert isinstance(script.attrs["src"], Traversable)

    # Render both
    target = PurePosixPath("mysite/pages/index.html")
    rendered_tree = render_path_nodes(path_tree, target)

    rendered_link = get_by_tag_name(rendered_tree, "link")
    rendered_script = get_by_tag_name(rendered_tree, "script")

    # Both should be regular Elements with string paths
    assert isinstance(rendered_link, Element)
    assert isinstance(rendered_script, Element)
    assert not isinstance(rendered_link, TraversableElement)
    assert not isinstance(rendered_script, TraversableElement)
    assert isinstance(rendered_link.attrs["href"], str)
    assert isinstance(rendered_script.attrs["src"], str)


# ==================================================
# Error Handling Tests
# ==================================================

def test_error_handling_missing_package():
    """Test error handling when package doesn't exist."""
    tree = html(t"""
        <html>
            <head>
                <link rel="stylesheet" href="nonexistent_package_xyz:static/styles.css">
            </head>
        </html>
    """)

    # Should raise ModuleNotFoundError or ImportError during transformation
    with pytest.raises((ModuleNotFoundError, ImportError)) as exc_info:
        make_path_nodes(tree, Heading)

    # Error should mention the missing package
    assert "nonexistent_package_xyz" in str(exc_info.value) or "No module named" in str(exc_info.value)


def test_error_handling_missing_asset_in_package():
    """Test error handling when asset doesn't exist in package."""
    tree = html(t"""
        <html>
            <head>
                <link rel="stylesheet" href="tests.fixtures.fake_package:static/nonexistent_file.css">
            </head>
        </html>
    """)

    # Should raise FileNotFoundError during transformation (asset validation)
    with pytest.raises(FileNotFoundError) as exc_info:
        make_path_nodes(tree, Heading)

    # Error should mention the missing file
    error_msg = str(exc_info.value)
    assert "nonexistent_file.css" in error_msg


def test_error_handling_missing_relative_asset():
    """Test error handling when relative asset doesn't exist (using component module)."""
    # Using Heading's module which doesn't have static/nonexistent_script.js
    tree = html(t"""
        <html>
            <head>
                <script src="static/nonexistent_script.js"></script>
            </head>
        </html>
    """)

    # Should raise FileNotFoundError during transformation
    with pytest.raises(FileNotFoundError) as exc_info:
        make_path_nodes(tree, Heading)

    # Error should mention the missing file
    error_msg = str(exc_info.value)
    assert "nonexistent_script.js" in error_msg


# ==================================================
# Tree Walker Integration Tests
# ==================================================

def test_tree_walker_preserves_non_asset_content():
    """Test that tree walker preserves content that isn't being transformed."""
    tree = html(t"""
        <html>
            <head>
                <meta charset="utf-8">
                <title>Test Page</title>
                <link rel="stylesheet" href="tests.fixtures.fake_package:static/styles.css">
            </head>
            <body>
                <h1>Welcome</h1>
                <p>Test content</p>
            </body>
        </html>
    """)

    # Transform
    path_tree = make_path_nodes(tree, Heading)

    # Verify meta and title preserved
    meta = get_by_tag_name(path_tree, "meta")
    title = get_by_tag_name(path_tree, "title")
    h1 = get_by_tag_name(path_tree, "h1")
    p = get_by_tag_name(path_tree, "p")

    assert meta.attrs["charset"] == "utf-8"
    assert len(title.children) > 0
    assert len(h1.children) > 0
    assert len(p.children) > 0



# ==================================================
# Backward Compatibility Tests
# ==================================================

def test_backward_compatibility_package_paths():
    """Test that package path syntax works correctly."""
    # This test verifies the new package path syntax
    tree = html(t"""
        <html>
            <head>
                <link rel="stylesheet" href="tests.fixtures.fake_package:static/styles.css">
                <link rel="stylesheet" href="tests.fixtures.fake_package:images/logo.png">
                <script src="tests.fixtures.fake_package:static/script.js"></script>
            </head>
        </html>
    """)

    # Should transform without errors
    path_tree = make_path_nodes(tree, Heading)

    # All should be TraversableElements
    from aria_testing import get_all_by_tag_name
    links = get_all_by_tag_name(path_tree, "link")
    script = get_by_tag_name(path_tree, "script")

    for link in links:
        assert isinstance(link, TraversableElement)
        assert isinstance(link.attrs["href"], Traversable)

    assert isinstance(script, TraversableElement)
    assert isinstance(script.attrs["src"], Traversable)


def test_external_urls_not_transformed():
    """Test that external URLs are left unchanged."""
    tree = html(t"""
        <html>
            <head>
                <link rel="stylesheet" href="https://cdn.example.com/style.css">
                <link rel="stylesheet" href="tests.fixtures.fake_package:static/styles.css">
            </head>
        </html>
    """)

    path_tree = make_path_nodes(tree, Heading)

    from aria_testing import get_all_by_tag_name
    links = get_all_by_tag_name(path_tree, "link")

    # First link (external) should be regular Element
    assert isinstance(links[0], Element)
    assert not isinstance(links[0], TraversableElement)
    assert links[0].attrs["href"] == "https://cdn.example.com/style.css"

    # Second link (package path) should be TraversableElement
    assert isinstance(links[1], TraversableElement)
    assert isinstance(links[1].attrs["href"], Traversable)


# ==================================================
# Type System Tests
# ==================================================

def test_traversable_type_throughout_pipeline():
    """Test that Traversable type is preserved correctly throughout pipeline."""
    # Verify make_path with package path returns Traversable
    pkg_traversable = make_path(None, "tests.fixtures.fake_package:static/styles.css")
    assert isinstance(pkg_traversable, Traversable)

    # Verify TraversableElement accepts Traversable
    elem = TraversableElement(
        tag="link",
        attrs={"rel": "stylesheet", "href": pkg_traversable},
        children=[]
    )
    assert isinstance(elem.attrs["href"], Traversable)

    # Verify render converts to string
    strategy = RelativePathStrategy()
    target = PurePosixPath("mysite/pages/index.html")

    from tdom_path.tree import _render_transform_node
    rendered = _render_transform_node(elem, target, strategy)
    assert isinstance(rendered, Element)
    assert not isinstance(rendered, TraversableElement)
    assert isinstance(rendered.attrs["href"], str)


def test_multiple_pages_same_component():
    """Test rendering same component tree for multiple target pages."""
    # Create tree once
    tree = html(t"""
        <html>
            <head>
                <link rel="stylesheet" href="tests.fixtures.fake_package:static/styles.css">
            </head>
        </html>
    """)

    # Transform to Traversable once
    path_tree = make_path_nodes(tree, Heading)

    # Render for different target pages
    targets = [
        PurePosixPath("mysite/index.html"),
        PurePosixPath("mysite/pages/about.html"),
        PurePosixPath("mysite/pages/docs/guide.html"),
    ]

    results = []
    for target in targets:
        rendered = render_path_nodes(path_tree, target)
        link = get_by_tag_name(rendered, "link")
        results.append(link.attrs["href"])

    # All should be strings
    for result in results:
        assert isinstance(result, str)
        assert len(result) > 0

    # Results should be different (different relative paths for each target)
    # Note: Actual path content depends on implementation details
    assert all(isinstance(r, str) for r in results)
